#include <mpi.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <tuple>
#include <algorithm>

#define TOP_N 3

struct TrafficRecord {
    int timestamp;
    int signal_id;
    int cars_passed;
};

int main(int argc, char** argv) {
    MPI_Init(&argc, &argv);
    int world_rank, world_size;
    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);
    MPI_Comm_size(MPI_COMM_WORLD, &world_size);

    std::vector<TrafficRecord> localRecords;
    std::map<int, int> localAggregation;

    if (world_rank == 0) {
        std::ifstream file("traffic_data.txt");
        if (!file.is_open()) {
            std::cerr << "Failed to open data file.\n";
            MPI_Abort(MPI_COMM_WORLD, 1);
        }

        int timestamp, signal_id, cars_passed;
        int target = 1;

        while (file >> timestamp >> signal_id >> cars_passed) {
            TrafficRecord rec = { timestamp, signal_id, cars_passed };
            MPI_Send(&rec, sizeof(TrafficRecord), MPI_BYTE, target, 0, MPI_COMM_WORLD);
            target = (target % (world_size - 1)) + 1;
        }

        // Send termination signals
        for (int i = 1; i < world_size; i++) {
            TrafficRecord dummy = { -1, -1, -1 };
            MPI_Send(&dummy, sizeof(TrafficRecord), MPI_BYTE, i, 1, MPI_COMM_WORLD);
        }

        // Gather from all consumers
        std::map<int, int> finalCounts;
        for (int i = 1; i < world_size; i++) {
            int count;
            MPI_Recv(&count, 1, MPI_INT, i, 2, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            for (int j = 0; j < count; j++) {
                int signal_id, total;
                MPI_Recv(&signal_id, 1, MPI_INT, i, 3, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
                MPI_Recv(&total, 1, MPI_INT, i, 4, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
                finalCounts[signal_id] += total;
            }
        }

        std::vector<std::pair<int, int>> sorted(finalCounts.begin(), finalCounts.end());
        std::sort(sorted.begin(), sorted.end(), [](auto &a, auto &b) {
            return a.second > b.second;
        });

        std::cout << "\nTop " << TOP_N << " Congested Signals:\n";
        for (int i = 0; i < std::min(TOP_N, (int)sorted.size()); ++i) {
            std::cout << "Signal " << sorted[i].first << " - Cars Passed: " << sorted[i].second << "\n";
        }
    } else {
        while (true) {
            TrafficRecord rec;
            MPI_Recv(&rec, sizeof(TrafficRecord), MPI_BYTE, 0, MPI_ANY_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            if (rec.timestamp == -1) break;
            localAggregation[rec.signal_id] += rec.cars_passed;
        }

        int localSize = localAggregation.size();
        MPI_Send(&localSize, 1, MPI_INT, 0, 2, MPI_COMM_WORLD);

        for (auto &entry : localAggregation) {
            MPI_Send(&entry.first, 1, MPI_INT, 0, 3, MPI_COMM_WORLD);
            MPI_Send(&entry.second, 1, MPI_INT, 0, 4, MPI_COMM_WORLD);
        }
    }

    MPI_Finalize();
    return 0;
}
