#include <mpi.h>
#include <iostream>
#include <vector>
#include <algorithm>
#include <ctime>

// Function to perform quicksort locally
void quicksort(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        int pivot = arr[high];
        int i = (low - 1);

        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                std::swap(arr[i], arr[j]);
            }
        }
        std::swap(arr[i + 1], arr[high]);
        int pi = i + 1;
        quicksort(arr, low, pi - 1);
        quicksort(arr, pi + 1, high);
    }
}

int main(int argc, char* argv[]) {
    MPI_Init(&argc, &argv);

    int rank, size;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    // Master process creates the array
    std::vector<int> data;
    if (rank == 0) {
        int n = 1000000; // Size of the array
        data.resize(n);
        for (int i = 0; i < n; i++) {
            data[i] = rand() % 1000000;
        }
    }

    // Scatter data among processes
    int n = data.size();
    int chunk_size = n / size;
    std::vector<int> local_data(chunk_size);

    MPI_Scatter(data.data(), chunk_size, MPI_INT, local_data.data(), chunk_size, MPI_INT, 0, MPI_COMM_WORLD);

    // Each process sorts its chunk
    quicksort(local_data, 0, chunk_size - 1);

    // Gather sorted chunks
    MPI_Gather(local_data.data(), chunk_size, MPI_INT, data.data(), chunk_size, MPI_INT, 0, MPI_COMM_WORLD);

    // Master process prints the result
    if (rank == 0) {
        // Optional: Print first 10 elements for verification
        for (int i = 0; i < 10; i++) {
            std::cout << data[i] << " ";
        }
        std::cout << "\n";
    }

    MPI_Finalize();
    return 0;
}
